<meta charset="utf-8"><link rel="stylesheet" href="apidoc.css">
<!-- http://casual-effects.com/markdeep/features.md.html -->

**Lava Vulkan Utilities**

## Overview

**Lava** is a toy C++ library composed of classes that make it easy to create and manage Vulkan
objects. It is open sourced under the MIT license, available at https://github.com/prideout/lava.

!!! Note
    Lava only creates and destroys Vulkan objects; it rarely adds to the command buffer. For
    example, the client application must invoke `vkCmdDraw` on its own, as well as any of the
    `VkCmdBind*` functions.

Select one of the classes below to see further documentation and usage examples.

- [LavaContext](#LavaContext)
  creates a **VkInstance**, **VkDevice**, **VkPhysicalDevice**, **VkSwapChain**, as well as
  several command buffers and related objects.
- [LavaDescCache](#LavaDescCache)
  creates a descriptor set layout and manages a set of corollary descriptors.
- [LavaPipeCache](#LavaPipeCache)
  manages a set of **VkPipeline** for a given layout.
- [LavaCpuBuffer](#LavaCpuBuffer)
  is a shared CPU-GPU buffer, useful for staging or uniform buffers.
- [LavaGpuBuffer](#LavaGpuBuffer)
  is a fast device-only buffer, useful for vertex buffers and index buffers.
- [LavaTexture](#LavaTexture) encapsulates a **VkImage**, a **VkImageView**, and a **VkBuffer**
  staging area.
- [LavaLoader](#LavaLoader)
  loads all Vulkan entry points. To use this feature, clients should include `LavaLoader.h` before
  (or instead of) including `vulkan/vulkan.h`.

Each Lava class is completely independent of every other class, so clients can choose a subset
of functionality as needed.

Lava lives in the `par` namespace, and every class is instanced using a static `create`
method. Most classes define a `Config` struct that gets passed into their constructor. We recommend
using initializer syntax to populate the config structure on the fly. For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
#include &lt;par/LavaGpuBuffer.h&gt;

using namespace par;

LavaGpuBuffer* lavabuffer = LavaGpuBuffer::create({ // pass in a Config struct
    .device = device,
    .gpu = physicalDevice,
    .size = sizeof(TRIANGLE_VERTICES),
    .usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT
});
const VkBuffer vkbuffer = lavabuffer->getBuffer();

// do stuff with the VkBuffer here...

LavaGpuBuffer::destroy(&lavabuffer);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Building and Running the Demos

On Linux, do this first:

```bash
sudo apt-get install libx11-dev libxinerama-dev libxcursor-dev
```

On macOS, you first need clang (which comes with Xcode) and homebrew, then do this:

```
brew install cmake ninja
```

!!! Note
    The demos require the contents of the
    [extras](https://github.com/prideout/lava/tree/master/extras) folder (including submodules) but
    the core Lava library has zero dependencies and can be built without fetching submodules.

Then, for any platform, do this:

1. Clone this repo with `--recursive` to get the submodules, or do `git submodule update --init`
   after cloning.
1. Install the LunarG Vulkan SDK.
1. Invoke the following commands in your terminal.
    ```bash
    cd [path to repo]
    mkdir .debug ; cd .debug ; cmake .. -G Ninja
    ninja && ./spinny_double
    ```

!!! WARNING
    On Linux, you may need to do this first, to choose clang over gcc:
    ```bash
    export CC=clang CXX=clang++
    ```

### LunarG SDK Instructions

1. Download the tarball from their website.
1. Copy or move its contents to `~/Vulkan`.  For example:
    `mv ~/Downloads/vulkansdk-macos-1.1.73.0 ~/Vulkan`
1. Add this to your `.bashrc`, replacing `macOS` as needed.

```bash
export VULKAN_SDK=$HOME/Vulkan
export VK_LAYER_PATH=$VULKAN_SDK/macOS/etc/vulkan/explicit_layers.d
export VK_ICD_FILENAMES=$VULKAN_SDK/macOS/etc/vulkan/icd.d/MoltenVK_icd.json
export PATH="$VULKAN_SDK/macOS/bin:$PATH"
```

## Components

### LavaContext

Use this class to create the standard litany of init-time Vulkan objects: an instance, a
device, a couple command buffers, etc. It requires a callback function that will create the window's
surface, which can easily be provided with a small lambda function.

!!! WARNING
    Lava does not contain platform-specific code so it cannot know about the windowing system. The
    app must provide a callback to create the **VkSurfaceKHR**.

For example, if your app uses  [GLFW](http://www.glfw.org/), you could initialize LavaContext like
so:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
auto context = LavaContext::create({
    .depthBuffer = false,
    .validation = true,
    .createSurface = [window] (VkInstance instance) {
        VkSurfaceKHR surface;
        glfwCreateWindowSurface(instance, window, nullptr, &surface);
        return surface;
    }
});
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After constructing the context, you can immediately extract the objects you need, such as the device
and backbuffer resolution:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
const VkDevice device = context->getDevice();
const VkExtent2D extent = context->getSize();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#### Frame API

You can use LavaContext as an aid for submitting command buffers and presenting the swap chain.
Simply wrap your command sequence in `beginFrame` / `endFrame` like this:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
VkCommandBuffer cmdbuffer = context->beginFrame();
vkCmdBeginRenderPass(cmdbuffer, &rpbi, VK_SUBPASS_CONTENTS_INLINE);
vkCmdBindPipeline(cmdbuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);
vkCmdBindVertexBuffers(cmdbuffer, 0, 1, buffer, offsets);
vkCmdDraw(cmdbuffer, 3, 1, 0, 0);
vkCmdEndRenderPass(cmdbuffer);
context->endFrame();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `beginFrame` method provides a double-buffered command buffer and automatically waits
for the previous buffer submission to finish executing. The `endFrame` method submits
the command buffer and presents the backbuffer.

In addition to `beginFrame` and `endFrame`, the context provides a `waitFrame` method, which allows
clients to wait until the most recently rendered frame presents itself.

#### Work API

TBD

#### Recording API

TBD

### LavaDescCache

### LavaPipeCache

This class makes it easy to create pipeline objects on the
fly, as well as modifying rasterization state:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
LavaPipeCache* pipelines = LavaPipeCache::create({
    .device = device,
    .vertex = {
        .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        .attributes = { {
            .binding = 0u,
            .format = VK_FORMAT_R32G32B32_SFLOAT,
            .location = 0u,
            .offset = 0u,
        } },
        .buffers = { {
            .binding = 0u,
            .stride = 12,
        } }
    },
    .descriptorLayouts = {},
    .vshader = vertexShaderModule,
    .fshader = fragmentShaderModule,
    .renderPass = renderPass
});
VkPipeline pipeline = pipelines->getPipeline();
// Do stuff here...
pipelines->setRenderPass(newRenderPass);
pipelines->setRasterState(newRasterState);
pipeline = pipelines->getPipeline();
// Do stuff here...
LavaPipeCache::destroy(&pipelines);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


### LavaCpuBuffer

### LavaGpuBuffer

### LavaTexture

### LavaLoader

## Internal Guidelines

### Visual Studio Code

Do this to enable intellisense and markdown highlighting:

```bash
cd [path to repo]
ln -s extras/vscode .vscode
```

### C++ Style

The code is vertically compact, but no single line should be longer than 100 characters. All
public-facing Lava types live in the `par` namespace.

For `#include`, always use angle brackets unless including a private header that lives in the same
directory. Includes are arranged in blocks, where each block is an alphabetized list of headers. The
first block is composed of `par` headers, followed by a sorted list of blocks for each `extern/`
library, followed by a block of C++ STL headers, followed by the block of standard C headers,
followed by the block of private headers. For example:

```cpp
#include &lt;par/LavaContext.h&gt;
#include &lt;par/LavaLog.h&gt;

#include &lt;SPIRV/GlslangToSpv.h&gt;

#include &lt;string&gt;
#include &lt;vector&gt;

#include "LavaInternal.h"
```

Methods and functions should have comments that are descriptive ("Opens the file") rather than
imperative ("Open the file").

<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>